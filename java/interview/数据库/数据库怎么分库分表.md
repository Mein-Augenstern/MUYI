看在前面
====

> * <a href="https://juejin.im/post/5dc77a9451882559465e390b">数据库怎么分库分表</a>

数据库瓶颈
------

不管是IO瓶颈还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载的活跃连接数的阈值。在业务service来看， 就是可用数据库连接少甚至无连接可用，接下来就可以想象了（并发量、吞吐量、崩溃）。

<h4>IO瓶颈</h4>

* 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询会产生大量的IO，降低查询速度->分库和垂直分表

* 第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 ->分库

<h4>CPU瓶颈</h4>

* 第一种：SQl问题：如SQL中包含join,group by, order by，非索引字段条件查询等，增加CPU运算的操作->SQL优化，建立合适的索引，在业务Service层进行业务计算。

* 第二种：单表数据量太大，查询时扫描的行太多，SQl效率低，增加CPU运算的操作。->水平分表。

分库分表
------

<h4>水平分库</h4>

![水平分库]()

1. 概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。

2. 结果：

  * 每个库的结构都一样
  
  * 每个库中的数据不一样，没有交集
  
  * 所有库的数据并集是全量数据
  
3. 场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库的情况下。

4. 分析：库多了，io和cpu的压力自然可以成倍缓解

<h4>水平分表</h4>

![水平分表]()

1. 概念：以字段为依据，按照一定策略（hash、range等），讲一个表中的数据拆分到多个表中。

2. 结果：

  * 每个表的结构都一样
  
  * 每个表的数据不一样，没有交集，所有表的并集是全量数据。
  
3. 场景：系统绝对并发量没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈，可以考虑水平分表。

4. 分析：单表的数据量少了，单次执行SQL执行效率高了，自然减轻了CPU的负担。

<h4>垂直分库</h4>

![垂直分库]()

1. 概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。

2. 结果：

  * 每个库的结构都不一样
  
  * 每个库的数据也不一样，没有交集
  
  * 所有库的并集是全量数据
  
3. 场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块的情况下。

4. 分析：到这一步，基本上就可以服务化了。例如：随着业务的发展，一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再者，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。
垂直分表

<h4>垂直分表</h4>

![垂直分表]()

1. 概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表中（主表和扩展表）。

2. 结果：

  * 每个表的结构不一样。
  
  * 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据。
  
  * 所有表的并集是全量数据。 
  
3. 场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大，以至于数据库缓存的数据行减少，查询时回去读磁盘数据产生大量随机读IO，产生IO瓶颈。

4. 分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能经常会查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表，这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获取全部数据就需要关联两个表来取数据。

但记住千万别用join，因为Join不仅会增加CPU负担并且会将两个表耦合在一起（必须在一个数据库实例上）。关联数据应该在service层进行，分别获取主表和扩展表的数据，然后用关联字段关联得到全部数据。

分库分表工具
------
